<!DOCTYPE html>
<html><head title="Doc"><meta charset="UTF-8"/><link href="styles.css" rel="stylesheet"/></head><body><nav class="sidebar"><h3>Modules</h3><ul><li><li><a href="Array.html">Array</a></li></li><li><li><a href="AssocList.html">AssocList</a></li></li><li><li><a href="Blob.html">Blob</a></li></li><li><li><a href="Buf.html">Buf</a></li></li><li><li><a href="Char.html">Char</a></li></li><li><li><a href="Debug.html">Debug</a></li></li><li><li><a href="Deque.html">Deque</a></li></li><li><li><a href="Func.html">Func</a></li></li><li><li><a href="Hash.html">Hash</a></li></li><li><li><a href="HashMap.html">HashMap</a></li></li><li><li><a href="Heap.html">Heap</a></li></li><li><li><a href="Int.html">Int</a></li></li><li><li><a href="Int16.html">Int16</a></li></li><li><li><a href="Int32.html">Int32</a></li></li><li><li><a href="Int64.html">Int64</a></li></li><li><li><a href="Int8.html">Int8</a></li></li><li><li><a href="Iter.html">Iter</a></li></li><li><li><a href="IterType.html">IterType</a></li></li><li><li><a href="List.html">List</a></li></li><li><li><a href="Nat.html">Nat</a></li></li><li><li><a href="Nat16.html">Nat16</a></li></li><li><li><a href="Nat32.html">Nat32</a></li></li><li><li><a href="Nat64.html">Nat64</a></li></li><li><li><a href="Nat8.html">Nat8</a></li></li><li><li><a href="None.html">None</a></li></li><li><li><a href="Option.html">Option</a></li></li><li><li><a href="Order.html">Order</a></li></li><li><li><a href="Prelude.html">Prelude</a></li></li><li><li><a href="Principal.html">Principal</a></li></li><li><li><a href="RBTree.html">RBTree</a></li></li><li><li><a href="Result.html">Result</a></li></li><li><li><a href="Text.html">Text</a></li></li><li><li><a href="Trie.html">Trie</a></li></li><li><li><a href="TrieMap.html">TrieMap</a></li></li><li><li><a href="TrieSet.html">TrieSet</a></li></li><li><li><a href="Word16.html">Word16</a></li></li><li><li><a href="Word32.html">Word32</a></li></li><li><li><a href="Word64.html">Word64</a></li></li><li><li><a href="Word8.html">Word8</a></li></li></ul><h3>Declarations</h3><ul><li><li><a href="#value.MAX_LEAF_SIZE">MAX_LEAF_SIZE</a></li></li><li><li><a href="#type.List">List</a></li></li><li><li><a href="#type.AssocList">AssocList</a></li></li><li><li><a href="#type.Key">Key</a></li></li><li><li><a href="#value.equalKey">equalKey</a></li></li><li><li><a href="#type.Leaf">Leaf</a></li></li><li><li><a href="#type.Branch">Branch</a></li></li><li><li><a href="#type.Trie">Trie</a></li></li><li><li><a href="#value.isValid">isValid</a></li></li><li><li><a href="#type.Trie2D">Trie2D</a></li></li><li><li><a href="#type.Trie3D">Trie3D</a></li></li><li><li><a href="#value.empty">empty</a></li></li><li><li><a href="#value.size">size</a></li></li><li><li><a href="#value.branch">branch</a></li></li><li><li><a href="#value.leaf">leaf</a></li></li><li><li><a href="#value.fromList">fromList</a></li></li><li><li><a href="#value.fromSizedList">fromSizedList</a></li></li><li><li><a href="#value.clone">clone</a></li></li><li><li><a href="#value.replace">replace</a></li></li><li><li><a href="#value.put">put</a></li></li><li><li><a href="#value.find">find</a></li></li><li><li><a href="#value.splitAssocList">splitAssocList</a></li></li><li><li><a href="#value.splitSizedList">splitSizedList</a></li></li><li><li><a href="#value.merge">merge</a></li></li><li><li><a href="#value.mergeDisjoint">mergeDisjoint</a></li></li><li><li><a href="#value.diff">diff</a></li></li><li><li><a href="#value.disj">disj</a></li></li><li><li><a href="#value.join">join</a></li></li><li><li><a href="#value.foldUp">foldUp</a></li></li><li><li><a href="#value.prod">prod</a></li></li><li><li><a href="#value.Build">Build</a></li></li><li><li><a href="#value.fold">fold</a></li></li><li><li><a href="#value.some">some</a></li></li><li><li><a href="#value.all">all</a></li></li><li><li><a href="#value.nth">nth</a></li></li><li><li><a href="#value.toArray">toArray</a></li></li><li><li><a href="#value.isEmpty">isEmpty</a></li></li><li><li><a href="#value.filter">filter</a></li></li><li><li><a href="#value.mapFilter">mapFilter</a></li></li><li><li><a href="#value.equalStructure">equalStructure</a></li></li><li><li><a href="#value.replaceThen">replaceThen</a></li></li><li><li><a href="#value.putFresh">putFresh</a></li></li><li><li><a href="#value.put2D">put2D</a></li></li><li><li><a href="#value.put3D">put3D</a></li></li><li><li><a href="#value.remove">remove</a></li></li><li><li><a href="#value.removeThen">removeThen</a></li></li><li><li><a href="#value.remove2D">remove2D</a></li></li><li><li><a href="#value.remove3D">remove3D</a></li></li><li><li><a href="#value.mergeDisjoint2D">mergeDisjoint2D</a></li></li></ul></nav><div class="documentation"><h1>Trie</h1><p>Functional map</p>
<p>Functional maps (and sets) whose representation is &quot;canonical&quot;, and
history independent.</p>
<h2 id="Background">Background</h2>

<p>See this POPL 1989 paper (Section 6):</p>
<ul><li><a href="https://dl.acm.org/citation.cfm?id=75305">&quot;Incremental computation via function caching&quot;, Pugh &amp; Teitelbaum</a>.</li><li><a href="http://matthewhammer.org/courses/csci7000-s17/readings/Pugh89.pdf">Public copy here</a>.</li></ul>

<p>By contrast, other usual functional representations of maps (AVL
Trees, Red-Black Trees) do not enjoy history independence, and are
each more complex to implement (e.g., each requires &quot;rebalancing&quot;;
these trees never do).</p>
<div class="declaration"><h4 class="value-declaration" id="value.MAX_LEAF_SIZE"><code><span class="keyword">public let </span><span class="fnname">MAX_LEAF_SIZE</span> : </code></h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.List"><span class="keyword">type </span><span class="type">List</span>&lt;<span class="type">T</span>&gt; = <span class="type">List.List</span>&lt;<span class="type">T</span>&gt;</h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.AssocList"><span class="keyword">type </span><span class="type">AssocList</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; = <span class="type">AssocList.AssocList</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.Key"><span class="keyword">type </span><span class="type">Key</span>&lt;<span class="type">K</span>&gt; = { hash : <span class="type">Hash.Hash</span>; key : <span class="type">K</span> }</h4><p></p></div><div class="declaration"><h4 class="function" id="value.equalKey"><code><span class="keyword">public func </span><span class="fnname">equalKey</span>&lt;<span class="type">K</span>&gt;(<span class="parameter">keq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>) : ((<span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <span class="type">Key</span>&lt;<span class="type">K</span>&gt;) -&gt; <span class="type">Bool</span>)</code></h4><p><p>Equality function for two <code>Key&lt;K&gt;</code>s, in terms of equality of <code>K</code>'s.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.Leaf"><span class="keyword">type </span><span class="type">Leaf</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; = { size : <span class="type">Nat</span>; keyvals : <span class="type">AssocList</span>&lt;<span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <span class="type">V</span>&gt; }</h4><p><p>leaf nodes of trie consist of key-value pairs as a list.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.Branch"><span class="keyword">type </span><span class="type">Branch</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; = { size : <span class="type">Nat</span>; left : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;; right : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; }</h4><p><p>branch nodes of the trie discriminate on a bit position of the keys' hashes.
we never store this bitpos; rather,
we enforce a style where this position is always known from context.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.Trie"><span class="keyword">type </span><span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt; = {#empty : (); #leaf : <span class="type">Leaf</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;; #branch : <span class="type">Branch</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;}</h4><p><p>binary hash tries: either empty, a leaf node, or a branch node</p>
</p></div><div class="declaration"><h4 class="function" id="value.isValid"><code><span class="keyword">public func </span><span class="fnname">isValid</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">enforceNormal</span> : <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="type-declaration" id="type.Trie2D"><span class="keyword">type </span><span class="type">Trie2D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt; = <span class="type">Trie</span>&lt;<span class="type">K1</span>, <span class="type">Trie</span>&lt;<span class="type">K2</span>, <span class="type">V</span>&gt;&gt;</h4><p><h2 id="Two-dimensional-trie">Two-dimensional trie</h2><p>A 2D trie is just a trie that maps dimension-1 keys to another
layer of tries, each keyed on the dimension-2 keys.</p>
</p></div><div class="declaration"><h4 class="type-declaration" id="type.Trie3D"><span class="keyword">type </span><span class="type">Trie3D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">K3</span>, <span class="type">V</span>&gt; = <span class="type">Trie</span>&lt;<span class="type">K1</span>, <span class="type">Trie2D</span>&lt;<span class="type">K2</span>, <span class="type">K3</span>, <span class="type">V</span>&gt;&gt;</h4><p><h2 id="Three-dimensional-trie">Three-dimensional trie</h2><p>A 3D trie is just a trie that maps dimension-1 keys to another
layer of 2D tries, each keyed on the dimension-2 and dimension-3 keys.</p>
</p></div><div class="declaration"><h4 class="function" id="value.empty"><code><span class="keyword">public func </span><span class="fnname">empty</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;() : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>An empty trie.</p>
</p></div><div class="declaration"><h4 class="function" id="value.size"><code><span class="keyword">public func </span><span class="fnname">size</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <span class="type">Nat</span></code></h4><p><p> Get the number of key-value pairs in the trie, in constant time.</p>
</p></div><div class="declaration"><h4 class="function" id="value.branch"><code><span class="keyword">public func </span><span class="fnname">branch</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">l</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">r</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Construct a branch node, computing the size stored there.</p>
</p></div><div class="declaration"><h4 class="function" id="value.leaf"><code><span class="keyword">public func </span><span class="fnname">leaf</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">kvs</span> : <span class="type">AssocList</span>&lt;<span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <span class="type">V</span>&gt;, <span class="parameter">bitpos</span> : <span class="type">Nat</span>) : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Construct a leaf node, computing the size stored there.</p>
<p>This helper function automatically enforces the MAX_LEAF_SIZE
by constructing branches as necessary; to do so, it also needs the bitpos
of the leaf.</p>
</p></div><div class="declaration"><h4 class="function" id="value.fromList"><code><span class="keyword">public func </span><span class="fnname">fromList</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">kvs</span> : <span class="type">AssocList</span>&lt;<span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <span class="type">V</span>&gt;, <span class="parameter">bitpos</span> : <span class="type">Nat</span>) : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.fromSizedList"><code><span class="keyword">public func </span><span class="fnname">fromSizedList</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">kvc</span> : ?<span class="type">Nat</span>, <br/>  <span class="parameter">kvs</span> : <span class="type">AssocList</span>&lt;<span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <span class="type">V</span>&gt;, <br/>  <span class="parameter">bitpos</span> : <span class="type">Nat</span><br/>) : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.clone"><code><span class="keyword">public func </span><span class="fnname">clone</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>Purely-functional representation permits <em>O(1)</em>-time copy, via persistent sharing.</p>
</p></div><div class="declaration"><h4 class="function" id="value.replace"><code><span class="keyword">public func </span><span class="fnname">replace</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k</span> : <span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">v</span> : ?<span class="type">V</span><br/>) : (<span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, ?<span class="type">V</span>)</code></h4><p><p>replace the given key's value option with the given one, returning the previous one</p>
</p></div><div class="declaration"><h4 class="function" id="value.put"><code><span class="keyword">public func </span><span class="fnname">put</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k</span> : <span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">v</span> : <span class="type">V</span><br/>) : (<span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, ?<span class="type">V</span>)</code></h4><p><p>put the given key's value in the trie; return the new trie, and the previous value associated with the key, if any</p>
</p></div><div class="declaration"><h4 class="function" id="value.find"><code><span class="keyword">public func </span><span class="fnname">find</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k</span> : <span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span><br/>) : ?<span class="type">V</span></code></h4><p><p> find the given key's value in the trie, or return null if nonexistent</p>
</p></div><div class="declaration"><h4 class="function" id="value.splitAssocList"><code><span class="keyword">public func </span><span class="fnname">splitAssocList</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">al</span> : <span class="type">AssocList</span>&lt;<span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <span class="type">V</span>&gt;, <span class="parameter">bitpos</span> : <span class="type">Nat</span>) : (<span class="type">AssocList</span>&lt;<span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <span class="type">V</span>&gt;, <span class="type">AssocList</span>&lt;<span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <span class="type">V</span>&gt;)</code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.splitSizedList"><code><span class="keyword">public func </span><span class="fnname">splitSizedList</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">l</span> : <span class="type">AssocList</span>&lt;<span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <span class="type">V</span>&gt;, <span class="parameter">bitpos</span> : <span class="type">Nat</span>) : (<span class="type">Nat</span>, <span class="type">AssocList</span>&lt;<span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <span class="type">V</span>&gt;, <span class="type">Nat</span>, <span class="type">AssocList</span>&lt;<span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <span class="type">V</span>&gt;)</code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.merge"><code><span class="keyword">public func </span><span class="fnname">merge</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">tl</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">tr</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p> merge tries, preferring the right trie where there are collisions
 in common keys. note: the <code>disj</code> operation generalizes this <code>merge</code>
 operation in various ways, and does not (in general) lose
 information; this operation is a simpler, special case.</p>
<p> See also:</p>
<ul><li><a href="#value.disj"><code>disj</code></a></li><li><a href="#value.join"><code>join</code></a></li><li><a href="#value.prod"><code>prod</code></a></li></ul></p></div><div class="declaration"><h4 class="function" id="value.mergeDisjoint"><code><span class="keyword">public func </span><span class="fnname">mergeDisjoint</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">tl</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">tr</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>like <code>merge</code>, it merges tries, but unlike <code>merge</code>, it signals a
dynamic error if there are collisions in common keys between the
left and right inputs.</p>
</p></div><div class="declaration"><h4 class="function" id="value.diff"><code><span class="keyword">public func </span><span class="fnname">diff</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">W</span>&gt;(<br/>  <span class="parameter">tl</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">tr</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">W</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p><p>The key-value pairs of the final trie consists of those pairs of
the left trie whose keys are not present in the right trie; the
values of the right trie are irrelevant.</p>
</p></div><div class="declaration"><h4 class="function" id="value.disj"><code><span class="keyword">public func </span><span class="fnname">disj</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">W</span>, <span class="type">X</span>&gt;(<br/>  <span class="parameter">tl</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">tr</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">W</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">vbin</span> : (?<span class="type">V</span>, ?<span class="type">W</span>) -&gt; <span class="type">X</span><br/>) : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">X</span>&gt;</code></h4><p><p>This operation generalizes the notion of &quot;set union&quot; to finite maps.</p>
<p>Produces a &quot;disjunctive image&quot; of the two tries, where the values of
matching keys are combined with the given binary operator.</p>
<p>For unmatched key-value pairs, the operator is still applied to
create the value in the image.  To accomodate these various
situations, the operator accepts optional values, but is never
applied to (null, null).</p>
<p>Implements the database idea of an <a href="https://stackoverflow.com/questions/38549/what-is-the-difference-between-inner-join-and-outer-join">&quot;outer join&quot;</a>.</p>
<p>See also:</p>
<ul><li><a href="#value.join"><code>join</code></a></li><li><a href="#value.merge"><code>merge</code></a></li><li><a href="#value.prod"><code>prod</code></a></li></ul></p></div><div class="declaration"><h4 class="function" id="value.join"><code><span class="keyword">public func </span><span class="fnname">join</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">W</span>, <span class="type">X</span>&gt;(<br/>  <span class="parameter">tl</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">tr</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">W</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">vbin</span> : (<span class="type">V</span>, <span class="type">W</span>) -&gt; <span class="type">X</span><br/>) : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">X</span>&gt;</code></h4><p><p>This operation generalizes the notion of &quot;set intersection&quot; to
finite maps.  Produces a &quot;conjuctive image&quot; of the two tries, where
the values of matching keys are combined with the given binary
operator, and unmatched key-value pairs are not present in the output.</p>
<p>Implements the database idea of an <a href="https://stackoverflow.com/questions/38549/what-is-the-difference-between-inner-join-and-outer-join">&quot;inner join&quot;</a>.</p>
<p>See also:</p>
<ul><li><a href="#value.disj"><code>disj</code></a></li><li><a href="#value.merge"><code>merge</code></a></li><li><a href="#value.prod"><code>prod</code></a></li></ul></p></div><div class="declaration"><h4 class="function" id="value.foldUp"><code><span class="keyword">public func </span><span class="fnname">foldUp</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">X</span>&gt;(<br/>  <span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">bin</span> : (<span class="type">X</span>, <span class="type">X</span>) -&gt; <span class="type">X</span>, <br/>  <span class="parameter">leaf</span> : (<span class="type">K</span>, <span class="type">V</span>) -&gt; <span class="type">X</span>, <br/>  <span class="parameter">empty</span> : <span class="type">X</span><br/>) : <span class="type">X</span></code></h4><p><p>This operation gives a recursor for the internal structure of
tries.  Many common operations are instantiations of this function,
either as clients, or as hand-specialized versions (e.g., see , map,
mapFilter, some and all below).</p>
</p></div><div class="declaration"><h4 class="function" id="value.prod"><code><span class="keyword">public func </span><span class="fnname">prod</span>&lt;<span class="type">K1</span>, <span class="type">V1</span>, <span class="type">K2</span>, <span class="type">V2</span>, <span class="type">K3</span>, <span class="type">V3</span>&gt;(<br/>  <span class="parameter">tl</span> : <span class="type">Trie</span>&lt;<span class="type">K1</span>, <span class="type">V1</span>&gt;, <br/>  <span class="parameter">tr</span> : <span class="type">Trie</span>&lt;<span class="type">K2</span>, <span class="type">V2</span>&gt;, <br/>  <span class="parameter">op</span> : (<span class="type">K1</span>, <span class="type">V1</span>, <span class="type">K2</span>, <span class="type">V2</span>) -&gt; ?(<span class="type">Key</span>&lt;<span class="type">K3</span>&gt;, <span class="type">V3</span>), <br/>  <span class="parameter">k3_eq</span> : (<span class="type">K3</span>, <span class="type">K3</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Trie</span>&lt;<span class="type">K3</span>, <span class="type">V3</span>&gt;</code></h4><p><p>Conditional <em>catesian product</em>, where the given
operation <code>op</code> <em>conditionally</em> creates output elements in the
resulting trie.</p>
<p>The keyed structure of the input tries are not relevant for this
operation: all pairs are considered, regardless of keys matching or
not.  Moreover, the resulting trie may use keys that are unrelated to
these input keys.</p>
<p>See also:</p>
<ul><li><a href="#value.disj"><code>disj</code></a></li><li><a href="#value.join"><code>join</code></a></li><li><a href="#value.merge"><code>merge</code></a></li></ul></p></div><div class="declaration"><h4 class="value-declaration" id="value.Build"><code><span class="keyword">public let </span><span class="fnname">Build</span> : </code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.fold"><code><span class="keyword">public func </span><span class="fnname">fold</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">X</span>&gt;(<br/>  <span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">f</span> : (<span class="type">K</span>, <span class="type">V</span>, <span class="type">X</span>) -&gt; <span class="type">X</span>, <br/>  <span class="parameter">x</span> : <span class="type">X</span><br/>) : <span class="type">X</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.some"><code><span class="keyword">public func </span><span class="fnname">some</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">f</span> : (<span class="type">K</span>, <span class="type">V</span>) -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.all"><code><span class="keyword">public func </span><span class="fnname">all</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">f</span> : (<span class="type">K</span>, <span class="type">V</span>) -&gt; <span class="type">Bool</span>) : <span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.nth"><code><span class="keyword">public func </span><span class="fnname">nth</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">i</span> : <span class="type">Nat</span>) : ?(<span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <span class="type">V</span>)</code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.toArray"><code><span class="keyword">public func </span><span class="fnname">toArray</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">W</span>&gt;(<span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">f</span> : (<span class="type">K</span>, <span class="type">V</span>) -&gt; <span class="type">W</span>) : [<span class="type">W</span>]</code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.isEmpty"><code><span class="keyword">public func </span><span class="fnname">isEmpty</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;) : <span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.filter"><code><span class="keyword">public func </span><span class="fnname">filter</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">f</span> : (<span class="type">K</span>, <span class="type">V</span>) -&gt; <span class="type">Bool</span>) : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.mapFilter"><code><span class="keyword">public func </span><span class="fnname">mapFilter</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">W</span>&gt;(<span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="parameter">f</span> : (<span class="type">K</span>, <span class="type">V</span>) -&gt; ?<span class="type">W</span>) : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">W</span>&gt;</code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.equalStructure"><code><span class="keyword">public func </span><span class="fnname">equalStructure</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">tl</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">tr</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">keq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">veq</span> : (<span class="type">V</span>, <span class="type">V</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Bool</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.replaceThen"><code><span class="keyword">public func </span><span class="fnname">replaceThen</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">X</span>&gt;(<br/>  <span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k</span> : <span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">v2</span> : <span class="type">V</span>, <br/>  <span class="parameter">success</span> : (<span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="type">V</span>) -&gt; <span class="type">X</span>, <br/>  <span class="parameter">fail</span> : () -&gt; <span class="type">X</span><br/>) : <span class="type">X</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.putFresh"><code><span class="keyword">public func </span><span class="fnname">putFresh</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k</span> : <span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">v</span> : <span class="type">V</span><br/>) : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;</code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.put2D"><code><span class="keyword">public func </span><span class="fnname">put2D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <span class="type">Trie2D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k1</span> : <span class="type">Key</span>&lt;<span class="type">K1</span>&gt;, <br/>  <span class="parameter">k1_eq</span> : (<span class="type">K1</span>, <span class="type">K1</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">k2</span> : <span class="type">Key</span>&lt;<span class="type">K2</span>&gt;, <br/>  <span class="parameter">k2_eq</span> : (<span class="type">K2</span>, <span class="type">K2</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">v</span> : <span class="type">V</span><br/>) : <span class="type">Trie2D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt;</code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.put3D"><code><span class="keyword">public func </span><span class="fnname">put3D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">K3</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <span class="type">Trie3D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">K3</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k1</span> : <span class="type">Key</span>&lt;<span class="type">K1</span>&gt;, <br/>  <span class="parameter">k1_eq</span> : (<span class="type">K1</span>, <span class="type">K1</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">k2</span> : <span class="type">Key</span>&lt;<span class="type">K2</span>&gt;, <br/>  <span class="parameter">k2_eq</span> : (<span class="type">K2</span>, <span class="type">K2</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">k3</span> : <span class="type">Key</span>&lt;<span class="type">K3</span>&gt;, <br/>  <span class="parameter">k3_eq</span> : (<span class="type">K3</span>, <span class="type">K3</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">v</span> : <span class="type">V</span><br/>) : <span class="type">Trie3D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">K3</span>, <span class="type">V</span>&gt;</code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.remove"><code><span class="keyword">public func </span><span class="fnname">remove</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k</span> : <span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span><br/>) : (<span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, ?<span class="type">V</span>)</code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.removeThen"><code><span class="keyword">public func </span><span class="fnname">removeThen</span>&lt;<span class="type">K</span>, <span class="type">V</span>, <span class="type">X</span>&gt;(<br/>  <span class="parameter">t</span> : <span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k</span> : <span class="type">Key</span>&lt;<span class="type">K</span>&gt;, <br/>  <span class="parameter">k_eq</span> : (<span class="type">K</span>, <span class="type">K</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">success</span> : (<span class="type">Trie</span>&lt;<span class="type">K</span>, <span class="type">V</span>&gt;, <span class="type">V</span>) -&gt; <span class="type">X</span>, <br/>  <span class="parameter">fail</span> : () -&gt; <span class="type">X</span><br/>) : <span class="type">X</span></code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.remove2D"><code><span class="keyword">public func </span><span class="fnname">remove2D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <span class="type">Trie2D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k1</span> : <span class="type">Key</span>&lt;<span class="type">K1</span>&gt;, <br/>  <span class="parameter">k1_eq</span> : (<span class="type">K1</span>, <span class="type">K1</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">k2</span> : <span class="type">Key</span>&lt;<span class="type">K2</span>&gt;, <br/>  <span class="parameter">k2_eq</span> : (<span class="type">K2</span>, <span class="type">K2</span>) -&gt; <span class="type">Bool</span><br/>) : (<span class="type">Trie2D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt;, ?<span class="type">V</span>)</code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.remove3D"><code><span class="keyword">public func </span><span class="fnname">remove3D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">K3</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <span class="type">Trie3D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">K3</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k1</span> : <span class="type">Key</span>&lt;<span class="type">K1</span>&gt;, <br/>  <span class="parameter">k1_eq</span> : (<span class="type">K1</span>, <span class="type">K1</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">k2</span> : <span class="type">Key</span>&lt;<span class="type">K2</span>&gt;, <br/>  <span class="parameter">k2_eq</span> : (<span class="type">K2</span>, <span class="type">K2</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">k3</span> : <span class="type">Key</span>&lt;<span class="type">K3</span>&gt;, <br/>  <span class="parameter">k3_eq</span> : (<span class="type">K3</span>, <span class="type">K3</span>) -&gt; <span class="type">Bool</span><br/>) : (<span class="type">Trie3D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">K3</span>, <span class="type">V</span>&gt;, ?<span class="type">V</span>)</code></h4><p></p></div><div class="declaration"><h4 class="function" id="value.mergeDisjoint2D"><code><span class="keyword">public func </span><span class="fnname">mergeDisjoint2D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt;(<br/>  <span class="parameter">t</span> : <span class="type">Trie2D</span>&lt;<span class="type">K1</span>, <span class="type">K2</span>, <span class="type">V</span>&gt;, <br/>  <span class="parameter">k1_eq</span> : (<span class="type">K1</span>, <span class="type">K1</span>) -&gt; <span class="type">Bool</span>, <br/>  <span class="parameter">k2_eq</span> : (<span class="type">K2</span>, <span class="type">K2</span>) -&gt; <span class="type">Bool</span><br/>) : <span class="type">Trie</span>&lt;<span class="type">K2</span>, <span class="type">V</span>&gt;</code></h4><p></p></div></div></body></html>