[[module.TrieMap]]
= TrieMap

Functional map

This module defines an imperative hash map, with a general key and value type.  It matches the interface and semantics of HashMap.  Unlike HashMap, its internal representation uses a functional hash trie (see `trie.mo`).

This class permits us to compare the performance of two representations of hash-based maps, where tries (as binary trees) permit more efficient, constant-time, cloning compared with ordinary tables.  This property is nice for supporting transactional workflows where map mutations may be provisional, and where we may expect some mutations to be uncommitted, or to "roll back".

For now, this class does not permit a direct `clone` operation (neither does `HashMap`), but it does permit creating iterators via `iter()`.  The effect is similar: Each iterator costs `O(1)` to create, but represents a fixed view of the mapping that does not interfere with mutations (it will _not_ view subsequent insertions or mutations, if any).

[[class.TrieMap]]
== TrieMap



[source,motoko]
----
class TrieMap<K, V>(isEq : (K, K) -> Bool, hashOf : (K) -> Hash.Hash)
----



[[value.size]]
=== size



[source,motoko]
----
func size() : Nat
----

[[value.put]]
=== put



[source,motoko]
----
func put(k : K, v : V)
----

[[value.replace]]
=== replace



[source,motoko]
----
func replace(k : K, v : V) : ?V
----

[[value.get]]
=== get



[source,motoko]
----
func get(k : K) : ?V
----

[[value.delete]]
=== delete



[source,motoko]
----
func delete(k : K)
----

[[value.remove]]
=== remove



[source,motoko]
----
func remove(k : K) : ?V
----

[[value.entries]]
=== entries

notably, each iterator gets a _persistent view_ of the mapping,
by virtue of the trie being a persistent data structure.

[source,motoko]
----
func entries() : I.Iter<(K, V)>
----

[[value.clone]]
== clone

clone cannot be an efficient object method,
...but is still useful in tests, and beyond.

[source,motoko]
----
func clone<K, V>(h : TrieMap<K, V>, keyEq : (K, K) -> Bool, keyHash : (K) -> Hash.Hash) : TrieMap<K, V>
----

[[value.fromEntries]]
== fromEntries

Clone from any iterator of key-value pairs

[source,motoko]
----
func fromEntries<K, V>(entries : I.Iter<(K, V)>, keyEq : (K, K) -> Bool, keyHash : (K) -> Hash.Hash) : TrieMap<K, V>
----

[[value.map]]
== map



[source,motoko]
----
func map<K, V1, V2>(h : TrieMap<K, V1>, keyEq : (K, K) -> Bool, keyHash : (K) -> Hash.Hash, mapFn : (K, V1) -> V2) : TrieMap<K, V2>
----

[[value.mapFilter]]
== mapFilter



[source,motoko]
----
func mapFilter<K, V1, V2>(h : TrieMap<K, V1>, keyEq : (K, K) -> Bool, keyHash : (K) -> Hash.Hash, mapFn : (K, V1) -> ?V2) : TrieMap<K, V2>
----

