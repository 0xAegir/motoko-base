= Using the {proglang} base library
:proglang: Motoko
:company-id: DFINITY

For various practical language engineering reasons, the design of {proglang} strives to minimize built-in types and operations.

Instead, whenever possible, the {proglang} base library provides the types and operations that make the language feel complete.

// Added for Hackathon
You can find the current list of modules and raw documentation for the operations they provide in  the base library
link:https://hydra.dfinity.systems/latest/dfinity-ci-build/motoko.pr-1561/base-doc/index.html[Index of Modules]
// End of section for Hackathon

__You should note, however, that this base library is still under development and documentation is incomplete__.
All base library APIs are subject to change over time and the size and number of modules and functions included in the base library is expected to increase dramatically as {proglang} evolves.

This section describes a _subset_ of modules from the {proglang} base library, with an emphasis on the modules that support core features and the libraries that are referenced in the examples.

== Importing from the base library

To import from the base library, use the `import` keyword.
Give a local module name to introduce, in this example `P` for
"`**P**relude`", and a URL where the `import` declaration may locate
the imported module:

....
import P "mo:base/Prelude";
P.printLn("hello world");
....

This example illustrates how to import {proglang} code—indicated by using the `mo:` prefix—using the `base/` base library path and the module name `prelude`.
You can also import {proglang} code and other modules using relative paths.
For example, if you have created a {proglang} program named types.mo in the same folder as your main program, you could include it with an import declaration like this:

....
import Types "./types";
....

[[compiler-prelude]]
== Using predefined compiler prelude function

The compiler itself contains a *prelude* in every program, effectively extending the language definition with a set of types and declarations that are always available.

In addition to these built-in compiler definitions, the prelude of the base library contributes some additional functions in a supplemental Prelude module.

In contrast to the definitions in other modules, the compiler prelude definitions are always present, and do _not_ require any `import` declaration to bring them into the current scope.

== Modules for data types and data structures

The base library provides one module for most basic types such as integers (`Int`) and characters (`Char`) to perform common operations. There are also modules for more advanced data structures such as `Trie` and 'HashMap' data structures and utility modules for performing common tasks such as iteration (`Iter`) and debugging (`Debug`).

=== Primitive data types

* link:Nat{outfilesuffix}[Nat]
* link:Int{outfilesuffix}[Int]
* link:Char{outfilesuffix}[Char]
* link:Text{outfilesuffix}[Text]
* link:None{outfilesuffix}[None]
* link:Option{outfilesuffix}[Option]
* link:Function{outfilesuffix}[Function]
* link:Array{outfilesuffix}[Array]
* link:Blob{outfilesuffix}[Blob=+1]
* link:Principal{outfilesuffix}[Principal]
* link:Ord{outfilesuffix}[Ord]

=== Complex data structures

* link:Result{outfilesuffix}[Result]
* link:Buf{outfilesuffix}[Buf]
* link:List{outfilesuffix}[List]
* link:Deque{outfilesuffix}[Deque]
* link:AssocList{outfilesuffix}[AssocList]
* link:Heap{outfilesuffix}[Heap]
* link:Hash{outfilesuffix}[Hash]
* link:HashMap{outfilesuffix}[HashMap]
* link:RBTree{outfilesuffix}[RBTree]
* link:Trie{outfilesuffix}[Trie]
* link:TrieMap{outfilesuffix}[TrieMay]
* link:TrieSet{outfilesuffix}[TrieSet]

=== Utilities
* link:Prelude{outfilesuffix}[Prelude]
* link:Iter{outfilesuffix}[Iter]
* link:Debug{outfilesuffix}[Debug]
